<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>skeleton visualization in webgl</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index: 100;
			}

		</style>
	</head>
	<body>

		<script type="text/javascript" src="../../libs/three.js/Three.js"></script>

		<script type="text/javascript" src="../../libs/three.js/js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="../../libs/three.js/js/Stats.js"></script>
    
        <script type="text/javascript" src="../../libs/jquery/jquery.js"></script>
        <script type="text/javascript" src="../../libs/jquery/jquery.url.js"></script>

		<script type="text/javascript">

			var camera, scene, renderer, particles, geometry, materials = [], parameters, i, h, color;
			var mouseX = 0, mouseY = 0,
                SEPARATION = 200, AMOUNTX = 10, AMOUNTY = 10;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
            var scale = $.url().param('scale') ? $.url().param('scale') : 1.0;

            jQuery.ajax({
              //url: "../../model/export.skeleton.json.php",
              url: "../../dj/"+$.url().param('project_id')+"/skeleton/" +
                      $.url().param('skeleton_id') + "/json",
              type: "GET",
              dataType: "json",
              success: function (text) {
                init();
                animate();
                debugaxes();
                draw_grid();
                draw_skeleton(text);
              }
            });

            function debugaxes(){
                //Axes array[x,y,z]
                var axisLength = 50;

                var info = [[-axisLength,0,0,axisLength,0,0,0xff0000],[0,-axisLength,0,0,axisLength,0,0x00ff00],[0,0,-axisLength,0,0,axisLength,0x0000ff]];

                //Draw some helpful axes
                for(i=0;i<3;i++){
                    material = new THREE.MeshBasicMaterial({color: 0xffffff});
                    geometry = new THREE.Geometry();

                    //Define the start point
                    particle = new THREE.Particle(material);
                    particle.position.x = info[i][0];
                    particle.position.y = info[i][1];
                    particle.position.z = info[i][2];

                    //Add the new particle to the scene
                    scene.addObject(particle);

                    //Add the particle position into the geometry object
                    geometry.vertices.push(new THREE.Vertex(particle.position));

                    //Create the second point
                    particle = new THREE.Particle(material);
                    particle.position.x = info[i][3];
                    particle.position.y = info[i][4];
                    particle.position.z = info[i][5];

                    //Add the new particle to the scene
                    scene.addObject(particle);

                    //Add the particle position into the geometry object
                    geometry.vertices.push(new THREE.Vertex(particle.position));

                    //Create the line between points
                    var line = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: info[i][6], opacity: 0.8, linewidth: 1}));
                    scene.addObject(line);
                }
            }

            function draw_skeleton(skeleton) {

				var line_material = new Object(),
                    type, from_vectr, to_vector, geometry = new Object();

                var connectivity_types = new Array('neurite', 'presynaptic_to', 'postsynaptic_to');

                geometry[connectivity_types[0]] = new THREE.Geometry();
                geometry[connectivity_types[1]] = new THREE.Geometry();
                geometry[connectivity_types[2]] = new THREE.Geometry();

                line_material[connectivity_types[0]] = new THREE.LineBasicMaterial( { color: 0xff0000, opacity: 1.0, linewidth: 3 } );
                line_material[connectivity_types[1]] = new THREE.LineBasicMaterial( { color: 0x00ff00, opacity: 1.0, linewidth: 6 } )
                line_material[connectivity_types[2]] =new THREE.LineBasicMaterial( { color: 0x0000ff, opacity: 1.0, linewidth: 6 } )

                var vertices = {
                    5: {'x': 0, 'y': 0, 'z': 0},
                    6: {'x': 300, 'y': 300, 'z': 300},
                    7: {'x': 300, 'y': 300, 'z': 200},
                    8: {'x': 200, 'y': 300, 'z': 200}
                };

                var connectivity = {
                    5 : { 6: {'type': 'neurite'},
                          7: {'type': 'presynaptic_to'}
                        },
                    7 : { 8: {'type': 'postsynaptic_to'}}
                };

                vertices = skeleton.vertices;
                connectivity = skeleton.connectivity;

                for (var fromkey in connectivity) {
                    var to = connectivity[fromkey];
                    for (var tokey in to) {

                        type = connectivity_types[connectivity_types.indexOf(connectivity[fromkey][tokey]['type'])];

                        from_vector = new THREE.Vector3(
                                vertices[fromkey]['x'],
                                vertices[fromkey]['y'],
                                vertices[fromkey]['z'] );
                        // transform
                        from_vector.multiplyScalar( scale );
                        geometry[type].vertices.push( new THREE.Vertex( from_vector ) );

                        to_vector = new THREE.Vector3(
                                vertices[tokey]['x'],
                                vertices[tokey]['y'],
                                vertices[tokey]['z'] );
                        to_vector.multiplyScalar( scale );
					    geometry[type].vertices.push( new THREE.Vertex( to_vector ) );
                    }
                }
                for ( var i=0; i<connectivity_types.length; ++i ) {
                    var line = new THREE.Line( geometry[connectivity_types[i]], line_material[connectivity_types[i]], THREE.LinePieces );
                    scene.add( line );
                }

            }

            function draw_grid() {
				// Grid

				var line_material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 0.2 } ),
					geometry = new THREE.Geometry(),
					floor = -75, step = 25;

				for ( var i = 0; i <= 40; i ++ ) {

					geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( - 500, floor, i * step - 500 ) ) );
					geometry.vertices.push( new THREE.Vertex( new THREE.Vector3(   500, floor, i * step - 500 ) ) );

					geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( i * step - 500, floor, -500 ) ) );
					geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( i * step - 500, floor,  500 ) ) );

				}

				var line = new THREE.Line( geometry, line_material, THREE.LinePieces );
				scene.add( line );
            }

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 50;

				scene = new THREE.Scene();
				//scene.fog = new THREE.FogExp2( 0x000000, 0.0007 );

                geometry = new THREE.CubeGeometry( 200, 200, 200 );
                material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );

                mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			}


			function onDocumentMouseMove( event ) {
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
			}

			function onDocumentTouchStart( event ) {
				if ( event.touches.length == 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
			}

			function onDocumentTouchMove( event ) {
				if ( event.touches.length == 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
                camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
				camera.lookAt( scene.position );
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
