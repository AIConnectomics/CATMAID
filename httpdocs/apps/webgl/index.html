<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>skeleton visualization in webgl</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index: 100;
			}

		</style>
	</head>
	<body>

		<script type="text/javascript" src="../../libs/three.js/Three.js"></script>

		<script type="text/javascript" src="../../libs/three.js/js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="../../libs/three.js/js/Stats.js"></script>
    
        <script type="text/javascript" src="../../libs/jquery/jquery.js"></script>
        <script type="text/javascript" src="../../libs/jquery/jquery.url.js"></script>

		<script type="text/javascript">

			var camera, scene, renderer, particles, geometry, materials = [], parameters, i, h, color, grid_lines;
			var mouseX = 0, mouseY = 0,
                SEPARATION = 200, AMOUNTX = 10, AMOUNTY = 10;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
            var scale = $.url().param('scale') ? $.url().param('scale') : 1.0;
            var translate_x = $.url().param('translate_x') ? $.url().param('translate_x') : 0.0;
            var translate_y = $.url().param('translate_y') ? $.url().param('translate_y') : 0.0;
            var translate_z = $.url().param('translate_z') ? $.url().param('translate_z') : 0.0;
            var project_id = $.url().param('project_id');
            var connectivity_types = new Array('neurite', 'presynaptic_to', 'postsynaptic_to');

            Array.max = function( array ){
                return Math.max.apply( Math, array );
            };
            Array.min = function( array ){
                return Math.min.apply( Math, array );
            };

            // A namespace for the WebGL viewer
            var WebGLViewer = new function()
            {

                var Skeleton = function( skeleton_data )
                {

                    this.translate = function( dx, dy, dz )
                    {
                        for ( var i=0; i<connectivity_types.length; ++i ) {
                            if( dx ) {
                                this.actor[connectivity_types[i]].translateX( dx );
                            }
                            if( dy ) {
                                this.actor[connectivity_types[i]].translateY( dy );
                            }
                            if( dz ) {
                                this.actor[connectivity_types[i]].translateZ( dz );
                            }
                        }
                    }
/*
                    this.scale = function( scaleX, scaleY, scaleZ )
                    {
                        for ( var i=0; i<connectivity_types.length; ++i ) {
                            console.log("scale");
                            this.actor[connectivity_types[i]].scale[0] = scaleX;
                        }

                    }
*/
                    this.getMin = function()
                    {

                    }

                    this.getMax = function()
                    {

                    }

                    this.updateCompositeActor = function()
                    {
                        for ( var i=0; i<connectivity_types.length; ++i ) {
                            this.actor[connectivity_types[i]] = new THREE.Line( this.geometry[connectivity_types[i]],
                                    this.line_material[connectivity_types[i]], THREE.LinePieces );
                        }
                        console.log("compoisite actor", this.actor);
                    }

                    this.removeActorFromScene = function()
                    {
                      for ( var i=0; i<connectivity_types.length; ++i ) {
                            scene.removeObject( this.actor[connectivity_types[i]] );
                        }
                        console.log("rmoeve actor from scene", this.geometry );
                    }

                    this.addCompositeActorToScene = function()
                    {
                        for ( var i=0; i<connectivity_types.length; ++i ) {
                            scene.add( this.actor[connectivity_types[i]] );
                        }
                    }

                    var type, from_vectr, to_vector;

                    this.line_material = new Object();
                    this.geometry = new Object();
                    this.actor = new Object();

                    this.geometry[connectivity_types[0]] = new THREE.Geometry();
                    this.geometry[connectivity_types[1]] = new THREE.Geometry();
                    this.geometry[connectivity_types[2]] = new THREE.Geometry();

                    this.line_material[connectivity_types[0]] = new THREE.LineBasicMaterial( { color: 0xff0000, opacity: 1.0, linewidth: 3 } );
                    this.line_material[connectivity_types[1]] = new THREE.LineBasicMaterial( { color: 0x00ff00, opacity: 1.0, linewidth: 6 } )
                    this.line_material[connectivity_types[2]] = new THREE.LineBasicMaterial( { color: 0x0000ff, opacity: 1.0, linewidth: 6 } )

                    this.original_vertices = skeleton_data.vertices;
                    this.original_connectivity = skeleton_data.connectivity;

                    for (var fromkey in this.original_connectivity) {
                        var to = this.original_connectivity[fromkey];
                        for (var tokey in to) {

                            type = connectivity_types[connectivity_types.indexOf(this.original_connectivity[fromkey][tokey]['type'])];

                            from_vector = new THREE.Vector3(
                                    this.original_vertices[fromkey]['x'],
                                    this.original_vertices[fromkey]['y'],
                                    this.original_vertices[fromkey]['z'] );
                            // transform
                            from_vector.multiplyScalar( scale );

                            this.geometry[type].vertices.push( new THREE.Vertex( from_vector ) );

                            to_vector = new THREE.Vector3(
                                    this.original_vertices[tokey]['x'],
                                    this.original_vertices[tokey]['y'],
                                    this.original_vertices[tokey]['z'] );
                            // transform
                            // to_vector.add( translate_x, translate_y, translate_z );
                            to_vector.multiplyScalar( scale );
                            
                            this.geometry[type].vertices.push( new THREE.Vertex( to_vector ) );
                        }
                    }

                    this.updateCompositeActor();

                }

                // array of skeletons
                var skeletons = new Object();
                
                // active node geometry
                var active_node;

                // fetch skeleton from database
                this.fetchSkeleton = function( skeleton_id )
                {
                    if( skeleton_id !== undefined )
                    {
                        jQuery.ajax({
                          //url: "../../model/export.skeleton.json.php",
                          url: "../../dj/"+project_id+"/skeleton/" + skeleton_id + "/json",
                          type: "GET",
                          dataType: "json",
                          success: function (skeleton_data) {
                            WebGLViewer.addSkeleton( skeleton_id, skeleton_data );
                          }
                        });
                    }
                }

                // add skeleton to scene
                this.addSkeleton = function( skeleton_id, skeleton_data )
                {
                    if( skeletons.hasOwnProperty(skeleton_id) ){
                        alert("Skeleton "+skeleton_id+" already added");
                        return;
                    } else {
                        skeletons[skeleton_id] = new Skeleton( skeleton_data );
                        skeletons[skeleton_id].addCompositeActorToScene();
                        return true;
                    }
                }

                // remove skeleton from scence
                this.removeSkeleton = function( skeleton_id )
                {
                    if( !skeletons.hasOwnProperty(skeleton_id) ){
                        alert("Skeleton "+skeleton_id+" does not exist. Cannot remove it!");
                        return;
                    } else {
                        skeletons[skeleton_id].removeActorFromScene();
                        delete skeletons[skeleton_id];
                        return true;
                    }
                }

                this.translateSkeletons = function( dx, dy, dz )
                {
                    console.log("trnslate skeleton");
                    for (skeleton_id in skeletons) {
                        if (skeletons.hasOwnProperty(skeleton_id)) {
                            console.log("translate");
                            skeletons[skeleton_id].translate( dx, dy, dz );
                        }
                    }
                }

                this.scaleSkeletons = function( scaleX, scaleY, scaleZ )
                {
                    console.log("scale skeleton");
                    for (skeleton_id in skeletons) {
                        if (skeletons.hasOwnProperty(skeleton_id)) {
                            skeletons[skeleton_id].scale( scaleX, scaleY, scaleZ );
                        }
                    }
                }

                this.randomColorizeCurrentSkeletons = function()
                {

                }

                // fetch again all current skeletons from database and regenerate geometry
                this.updateSkeletons = function()
                {

                }

                // center and scale all currently added skeletons
                this.center_and_scale = function()
                {

                }

            }

            init();
            animate();
            debugaxes2();
            draw_grid();
            create_activenode();
            
            WebGLViewer.fetchSkeleton( $.url().param('skeleton_id') );

            // the active node as a sphere
            function create_activenode(  )
            {
                var material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
                var object = THREE.SceneUtils.createMultiMaterialObject( new THREE.SphereGeometry( 75, 20, 10 ), material );
                // object.position.set( data['x'], data['y'], data['z'] );
                object.position.set( 0, 0, 0 );
                scene.add( object );

                var gg = new THREE.CubeGeometry( 10, 10, 100 );
                var mm = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );

                var mesh = new THREE.Mesh( gg, mm );
                mesh.position.set(100, 100, 0);
                scene.add( mesh );
            }

            function debugaxes2() {
				var object = new THREE.Axes();
				object.position.set( 0, 0, 0 );
				object.scale.x = object.scale.y = object.scale.z = 0.5;
				scene.add( object );
            }

            function draw_grid() {
				// Grid

				var line_material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 0.2 } ),
					geometry = new THREE.Geometry(),
					floor = -75, step = 25;

				for ( var i = 0; i <= 40; i ++ ) {

					geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( - 500, floor, i * step - 500 ) ) );
					geometry.vertices.push( new THREE.Vertex( new THREE.Vector3(   500, floor, i * step - 500 ) ) );

					geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( i * step - 500, floor, -500 ) ) );
					geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( i * step - 500, floor,  500 ) ) );

				}

				grid_lines = new THREE.Line( geometry, line_material, THREE.LinePieces );
				scene.add( grid_lines );
            }

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 50;

				scene = new THREE.Scene();

				//scene.fog = new THREE.FogExp2( 0x000000, 0.0007 );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			}


			function onDocumentMouseMove( event ) {
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
			}

			function onDocumentTouchStart( event ) {
				if ( event.touches.length == 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
			}

			function onDocumentTouchMove( event ) {
				if ( event.touches.length == 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
                camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
				camera.lookAt( scene.position );
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
